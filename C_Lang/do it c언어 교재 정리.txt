do it c언어 교재 정리

1비트는 0,1중 한개를 저장
2비트면 00,01,10,11 4가지 가능 
32비트 2^32  #1비트 증가할 때마다 저장 단위는 2배로 늘어남 
8비트=1바이트는 숫자 2^8=256중 하나를 저장할 수 있는 크기임
부호표현--
0을 양수에 포함시킴 1바이트 기준으로 비트1개에 음수or양수 상태저장후 
나머지 비트7개에는 숫자를 저장. -128~127사이의 숫자 중 하나를 저장
ex_01111111 은127  10000000 은 -128 11111111 은 -1

자료형--
signed char 부호가 있는 1바이트 저장공간 #첫1비트는 부호비트 나머지7비트에 숫자를 저장 즉,-128~127의 숫자 중 하나를 저장할 수 있는크기
ex)기온
unsigned char 부호가 없는 1바이트 저장공간 #0	~256개의 숫자중 하나를 저장할 수 있는크기 ex)사람나이
signed short int  부호가 있는 2바이트 저장공간
1비트는 부호비트 나머지15비트에만 숫자를 저장 ex)d-day
unsigned short int 부호가 없는 2바이트 저장공간
2^16전체를 숫자 저장 공간으로 사영 65536개의 숫자 중 하나를 저장
signed long int 부호가 있는 4바이트 저장공간
unsigend long int 부호가 없는 4바이트 저장공간 2^32개의 숫자중 하나를 저장할 수 있는크기

실수형--
E2는 10^2을 의미 3.12567E2=312.567
float는 4바이트 double은 8바이트
float는 소수점이하6자리밖에안됨 6자리 이상 사용하려면 64비트기반인 double 자료형을 사용해야 합니다.

5장함수---
한개의 프로그램에서 main함수는 반드시 한개만 있어야함
피호출자>호출자순으로 or 함수선언하고 main밑에 함수정의

6장-----
라이브러리: C에서 함수를 효과적으로 관리할 수 있도록 제공하는기술
6-3 전처리기 : 프로그래머가 원하는 사항을 컴파일러에 직접지시하는 문법
#으로 시작 ;사용XX
#include "읽을파일 이름" OR<> :소스파일에 헤더파일을 포함하여 컴파일
#define 전처리기는 상수나 명령문을 치환하는 문법
#define 치환할이름 치환할내용  ex) #define MAX_COUNT 3
3이라는 상수를 MAX_COUNT로 치환
int data=MAX_COUNT;
#define POWVALUE(a)  (a*a)
int data =POWVALUE(3);  int data = (3*3); 으로 번역됨

7장 연산자----

8장 조건문---
if(조건수식) 명령문;
switch조건문  정해진 상수를 여러번 비교하는경우 switch문이 효율적
switch(수식 또는 변수){
	case 상수1;
	명령문2;
	break;
	
	default;
	------;
}
명령문5;

9장-반복문
for(시작조건;종결조건;조건변화수식) 명령문;
while(종결조건) 명령문;

10장----비트/시프트연산자
c언어의 가장 작은 자료형은 1바이트
오버플로:비트가 왼쪽으로 이동해서 사라지는것
<<특성: n개의 비트를 왼쪽으로 2^n을 곱한것과 동일
시프트연산자는 곱/나눗셈연산자보다 연산 속도가 빠름
최상위비트=부호비트 0이면양수,1이면음수
signed 형식으로 선언된 변수들에 >>를 사용하면 자신의 부호를 유지하기위해 부호비트와 동일한 값으로 채움
xor연산자 :a,b값이 같으면 0 다르면1
비트 연산자는 최소1바이트 단위로 연산
부호를 고려하지않는 1바이트 메모리는 255보다 더 큰값을 저장하면 오버플로우가 발생해 값을 잃어버림
비트반전=1의보수
+1하는것을 2의보수라고함
A-B 를 A+ ~B +1 을 해도됨 

11장----지역변수와 전역변수
지역변수 : 함수안에 선언한 변수나 매개변수/함수와같은 수명을가짐
스스로 초기화 되지않는다.
static키워드 전역변수를 특정 함수 안에서만 사용하도록 제한
지역변수의 특성을 가지지만, 생명주기는 전역변수와 동일

부록----
빅 엔디언 방식:메모리에 값을 저장할때 메모리 주소가 낮은쪽에서 높은쪽으로 저장 /RISC기반의 유닉스와 리눅스가 이방식으로 바이트를 정렬
낮은주소 0x12 0x34 0x56 0x78 높은주소
리틀 엔디언 방식: 0X12345678을 4바이트 메모리에 저장할때 작은 자릿수의 값부터 저장 /CISC기반의 윈도우 운영체제는 이방식으로 바이트를 정렬
낮은주소 0x78 0x56 0x34 0x12 높은주소 

12장--배열과 문자열
배열:자료형이 같은 변수들을 그룹으로 묶어서 관리할때
자료형 변수이름 [요소개수];  
문자열을 다루는 c내장함수 string.h 파일에서 함수의 원형제공
strlen : 문자열의 길이를 구하는 문자열 표준 함수
strcpy : 문자열을 복사하는 문자열 표준함수
strcat: 문자열 뒤에 다른 문자열을 덧붙이는 문자열 표준함수
2차원 배열

13장--포인터
64비트 운영체제의 장단점
동시처리능력이 좋음/ram을 2^64까지(16EB) 사용가능
32비트는 2^32>42GB까지 사용가능
운영체제는 메모리 주소를 1바이트 단위로 관리
102번지에 1042라는값을 2바이트크기로 저장하겠다
2바이트,short형
1042는 4와 18로 나누어짐 2진수:0000 0100 0001 0010 
10진수: 4와18!  16진수 : 0x04  0x12 바이트단위로저장:0x0412
1042값은 8비트에 저장할수없기 때문에 두개의 8비트에 나누어저장
102번지에18, 13번지에 4가저장 
윈도우는 리틀엔디안 바이트정렬 그러므로 18,4로저장
뒷번호가 먼저저장 18부터!
빅엔디안이면 4,18
c언어는 간접주소지정방식으로 동작하는 포인터문법을 제공
자신이 사용하고싶은 메모리의 주소를 저장하고있는 메모리가포인터
포인터변수는 자료형을 선언하지않아도 무조건4바이트(32비트니까)
short *ptr :자료형 *포인터변수이름
ptr포인터변수는 4바이트 
ptr포인터가 가리키는 대상은 short형 2바이트
*ptr=0x0412;  // birthday=0x0412;와 같은결과
ptr =  :포인터 변수의 값이 변경
*ptr = :포인터가 가리기키는 대상의 값이변경
const int *0 :*p의 값을 변경하려면 오류(대상을 const)
int * const p: p값이 변경되면 오류(자신을 const)
const int * const p; 둘다 오류
--포인터변수의주소연산
short dat=0;
short*p=&data;
p = p+1; //포인터변수에 저장된 주소값을 1만큼증가
포인터에서 +1의 의미는 그 다음 데이터의 주소를의미
원래 p에저장된주소값이 100이였다면 101이아니라 102로되는것
p+2면 104 p+@ :@는 포인터가 가리키는 대상의 크기가얼마냐에따라 달라짐  int*p였다면 p+1은 4씩증가 104!
포인터 변수를 선언할떄 *연산자 앞에 적는 자료형은 포인터변수가 가리키는 대상의 크기를 의미 int *p;
int data=0x12345678,i;
char*p=(char*)&data;
//4바이트 데이터를 바이트 단위로 값을 출력하기 위해 4번반복
for(i=0;i<4;i++){
	printf("%X,",*p); //p가 가진 주소부터 1바이트 크기만 사용
	p+++; //p가 가리킬 수 있는 크기(1바이트)만큼 주소증가
	}
}   16진수로 표시 >한자리가 4비트니까 2자리면 한바이트!
리틀엔디안 방식이니  data변수(4바이트)
0x78 0x56 0x34 0x12 로 메모리에 저장
p는 0x78 한바이트만 가리키는중 p+1은 0x56 가리키는중
void 키워드:정해져 있지 않다
포인터변수가 가리키는 대상의 크기를 모를떄 void*p 사용

14장----표준입력함수
표준입력버퍼: 특정 키를 누를떄까지 사용자입력을 임시로 저장하는 메모리  ex)키보드에서 "abc"입력>> 입력버퍼에 "abc"저장
*문자 한 개를 입력받는 getchar 함수:문자 한개를 입력받더라고 enter키를 눌러야만 작업이 완료됨
int input_data=getchar() //표준입력함수를 사용하여 문자한개를 입력
printf("input : %c\n",input_data);  //입력받은 문자 출력
rewind(stdin) //표준 입력 버퍼에있는 모든 입력 값을제거
*문자열을 입력받는 gets함수 enter키를 입력할떄까지 입력한 모든 문자를 하나의 문자열로본다.
char input_string[10];
gets(input_string); //문자열을 입력받아 input_string에저장
printf("input : %s\n",input_string);
gets함수는 입력 버퍼에 enter키가 남지 않는다.
enter키를 입력한 위치에 null문자0이 추가된다
gets 함수로 입력받은 숫자는 정수가 아닌 문자열로 인식됨
int data = "12345" //오류!! 문자열은 정수형 변수에 대입 불가!
만능표준입력함수 scanf 문자,문자열,정수,실수까지 모두 입력받기가능
%d 정수 %h short int %f 실수 %lf double %c %s
int data;
scanf("%d",&data); 
scanf(입력형식지정키워드,입력받은값저장할변수주소)
scanf 함수에서&연산자의 이유
scanf함수는 포인터 기술을 사영하여 값을 반환
scanf함수에서 입력된값을 구분하는 방법
1.엔터키를 사용하여 구분하기 2.공백을 사용하여 구분하기
-----------------------
15장 배열과 포인터
code에 !!
--------
16장 메모리할당
프로그램:프로그래머가 만든 프로그램 실행파일
프로세스:cpu가 실행파일에 있는 명령들을 실행할 수 있도록 운영체제가 실행 파일의 명령들을 읽어서 메모리에 재구성한것.
데이터를 저장할 공간을 적정하게 나누는 작업이 메모리할당!
정적메모리할당: 컴파일러가 그시점에 변수에 크기에 맞게 메모리를 할당하는것/프로그램이 실행될 때 메모리의 위치가 결정됨
정적으로 할당된 메모리를 관리하는법:지역변수를 시작위치 포인터와 끝 위치포인터를 사용하여 관리가능
프로세스 안에서 지역변수가 저장되는 기본스택 메모리 크기는 1MByte
char data[1024*1024] //오류발생!!
동적메모리할당!!: 원하는 시점에 원하는 크기만큼 힙메모리에 할당가능
메모리사용이 끝나면 언제든지 할당한 메모리 해제가능/Giga byte단위까지 할당가능
c표준함수 malloc함수를 사용해서 메모리할당가능
함수원형: void*malloc(size);  size는 unsigned int와 같은 자료형
함수 사용형식 : void *p=malloc(100);  100바이트의 메모리를 할당하여 포인터p에저장

17장---------------다차원포인터
다차원포인터:간접으로 여러번 대상을 가리키는 포인터
차원은 자신이 가리키는 대상의 개수만큼 증가
short *p,data=5;
p= &data; //포인터 변수p는 data변수의 주소값을 기억
1차원포인터변수!--가리키는 대상이 1개니까
포인터 변수 선언시 *키워드를 추가할 때마다 차원이 하나씩증가
포인터 변수 선언시 사용한 *키워드 개수만큼 포인터를 사용할 때 *연산자 사용가능
char *p1;  //1차원포인터 : p1,*p1  자기자신or자기가 가리키는 대상
char **p2; //2차원포인터 : p2,*p2,**p2  나도or동훈이or동훈이친구
나 나의친구 나의친구의친구 느낌

18장 ----------구조체와 연결리스트

19장-----------파일입출력

1장부록
빅 엔디언 방식:메모리에 값을 저장할때 메모리 주소가 낮은쪽에서 높은쪽으로 저장 /RISC기반의 유닉스와 리눅스가 이방식으로 바이트를 정렬
낮은주소 0x12 0x34 0x56 0x78 높은주소
리틀 엔디언 방식: 0X12345678을 4바이트 메모리에 저장할때 작은 자릿수의 값부터 저장 /CISC기반의 윈도우 운영체제는 이방식으로 바이트를 정렬
낮은주소 0x78 0x56 0x34 0x12 높은주소 

2장부록
공용체를 적재적소에 활용하면 메모리를 절약가능
typedef union convertdata{
    char c_data;  //1바이트
    short int s_data;  //2바이트
    int i_data;   //4바이트
}cd;

cd temp;  //union convertdata temp;와 같음
//공용체의 요소들은 할당된 메모리를 공유
공용체로 만든 자료형의 크기는 요소 중 가장큰 요소의 크기와 동일

전처리기 #define과 사용자 정의 자료형을 만드는typedef문법 헷갈리지말자

typedef unsigend short int* psi;  //psi라는 새자료형을 정의
#define psi unsigned short int*  // 위치가 반대!!

*p++: 자신이 가리키는 주소에 저장된 값을 사용한후 자신의 주소를 증가
*++p: 자신의주소를 증가시킨 후에 그 주소에 가서 값을 사용
++*p: p가 가지고 있는 주소에 저장된 값을 1만큼증가

































